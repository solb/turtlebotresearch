The code has a lot of parameters, so here's a quick guide to tuning them; I'd recommend proceeding in the same order as I address them.  All of the parameters' default values are hardcoded in at the beginning of the main function, but they can be changed in real time using: $ rosparam set /surface/<parameter> <value>
The crop settings should reflect the robot's width, height, and the search distance.  While setting these constants, one should look at the /surface/height topic in a visualizer such as RViz.  First, place a couple of objects on either side of the robot, just far enough apart that it could pass between them if it drove straight forward.  Set the |crop_xradius| high enough that they both appear in the visualizer, then decrease it until they just barely vanish.  (Note that, because of the way RViz handles updates, it will continue to show the last frame until it receives an update.  In order to see their disappearance, it will be necessary to [a] watch for the view to freeze, [b] place some other object within range so that there are always points visible, or [c] configure a Decay Time on RViz's display of the topic.)  Next, set the |crop_ymax| low enough that the ground comes into view, then decrease it until it vanishes completely and stands no danger of reappearing during sudden stops.  Place some object just above the robot's highest point and decrease |crop_ymin| until it appears, then increase it again until it is gone.  You should probably leave |crop_zmin| at 0.0 unless you have a specific reason to exclude closer objects, but set |crop_zmax| to a range that allows the robot to see far enough ahead while avoiding severe noise and retaining maneuverability (since it will turn away as soon as anything enters this region).
The height settings are used for the cropping approach to obstacle detection.  It's probably easiest to tune these while looking at both /surface/height and /surface/panorama.  First, set |height_downsampling| to a *very* low value such that you get a really high-resolution scan.  Notice the noise near--perhaps even in--the /surface/height region, which will be more prevalent toward the back of this area; this is bad!  Increase the value until this is no longer a problem.  The |height_samples| represents the number of point counts that are averaged before passing a verdict on whether to keep driving straight; it's probably safe as long as it is greater than 1 or 2, but should be increased if we're seeing a lot of false positives.  Enabling |height_verbose| may help to diagnose the latter.
All that ground stuff is for the plane analysis portion of the code.  You probably want to look at a combination of /surface/occlusions and /surface/ground to get these set up, but it's important that the robot is looking at a flat section of the ground.  Begin by setting |ground_farz| equal to |crop_zmax| and tuning |ground_fary| to a value--typically somewhere in the ballpark of 0.5--that brings the back few points of the ground plane into view on /surface/ground.  Next, set |ground_closez| and |ground_closey| to the coordinates of the closest edge of the ground plane; one thing that may help you to find the right values is playing with the values of |crop_zmin| and |crop_ymax| while watching the floor on /surface/height for a second.  Proceed by starting |ground_bumperlateral| and |ground_bumperfrontal| to 0.0.  The former is pretty forgiving; just increase it slightly until the left and right borders of the plane are no longer reflected in the /surface/occlusions stream.  The latter, however, probably needs to be set a bit higher, especially if your |crop_zmax| is quite high; you'll know this is the case if /surface/occlusions starts to pick up on missing chunks on either the front or rear edge of the ground plane.  Now decrease the |ground_tolerancerough| until you see hardly any points on /surface/ground and increase it until you just see the ground, without any of the junk that may be placed on it.  Move that value into |ground_tolerancefine| and increase |ground_tolerancerough| until you also see the bottom couple centimeters of that junk you just put in the way.
Now it's time to fix the curvature detection thresholds.  Still looking at /surface/occlusions and /surface/ground, set |ground_outlerradius| to -1 to temporarily disable the outlier detection.  If you see a bunch of false positives, increase |ground_thresholdlower| and |ground_thresholdhigher|--maybe to somewhere around 1 and 2, respectively?--and play with them until you've gotten rid of most of those buggers without losing the edges of any actual obstacles.  The way this works is:  Any points with curvature changes under |ground_thresholdlower| are immediately discared, so increasing this number will help to get rid of false positive points that are more or less isolated from any others.  Points with curvature changes between |ground_thresholdlower| and |ground_thresholdhigher| are kept only if they're part of the same edge as those with changes above |ground_thresholdhigher|, so decreasing |ground_thresholdhigher| will help to restore the desired edges if they were trimmed back heavily when you increased |ground_thresholdlower|.  Your goal here is really to eliminate the large clusters of false positives, while maybe still being left with a few more isolated ones.  At this point, you can set |ground_outlierradius| to a value that hopefully banishes some more of the false positive points, but is big enough to not eliminate the edges you actually care about.  Modifying |ground_outlierneighbors|, the minimum number of neighbors within the radius before a point is not considered an outlier, will help to get the outlier removal just right.  If anything weird ends up happening, you may be able to narrow down what's going wrong by enabling |ground_verbose|.
Ready to actually go somewhere?  Set |drive_move| and watch out!  You can set |drive_linearspeed| to whatever seems safe, but you might need to decrease |drive_angularspeed| a bit if you're running on a slow enough chip that the ground plane edge detection is a bit slow; a symptom of this is the robot's spinning past a traversable opening when it's in the middle of a turn as if it didn't see it.  Sometimes it's nice to see what went into the driving decisions; if this describes you, go ahead and activate |drive_verbose|.
